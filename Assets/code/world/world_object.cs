using System.Collections;
using System.Collections.Generic;
using UnityEngine;

/// <summary> An object generated by the world generator. </summary>
public abstract class world_object : MonoBehaviour
{
    public chunk chunk { get; private set; }
    public int x_in_chunk { get; private set; }
    public int z_in_chunk { get; private set; }
    public biome.point point { get; private set; }
    public Vector3 terrain_normal { get; private set; }

    /// <summary> Called when the world object is placed by a chunk. </summary>
    public abstract void on_placement();

    /// <summary> Called when the world object is placed by a chunk. </summary>
    public void on_placement(Vector3 terrain_normal, biome.point point,
                             chunk chunk, int x_in_chunk, int z_in_chunk)
    {
        this.chunk = chunk;
        this.x_in_chunk = x_in_chunk;
        this.z_in_chunk = z_in_chunk;
        this.point = point;
        this.terrain_normal = terrain_normal;
        on_placement();

        while (true)
        {
            bool gen = false;
            foreach (var sg in GetComponentsInChildren<sub_generator>())
                if (!sg.generated)
                {
                    sg.on_placement(point, chunk, x_in_chunk, z_in_chunk);
                    gen = true;
                }

            if (!gen) break; // All generators finished
        }
    }

    /// <summary> Should return false if this world object is incompatible 
    /// with the given terrain normal. </summary>
    public virtual bool can_place(Vector3 terrain_normal)
    {
        return true;
    }

    /// <summary> Should return false if this world object is incompatible 
    /// with the given <see cref="biome.point"/>. </summary>
    public virtual bool can_place(biome.point p)
    {
        return true;
    }

    /// <summary> Load a world object from the resources/world_objects
    /// folder (saves results in a dictionary for speedy access). </summary>
    public static world_object load(string name)
    {
        if (_library == null)
        {
            _library = new Dictionary<string, world_object>();
            foreach (var o in Resources.LoadAll<world_object>("world_objects/"))
                _library[o.name] = o;
        }
        if (_library.TryGetValue(name, out world_object found))
            return found;
        Debug.LogError("The world object \"" + name + "\" was not found!");
        return null;
    }
    static Dictionary<string, world_object> _library;

    /// <summary> Load a random object from the list. </summary>
    public static world_object load(System.Random rand, params string[] names)
    {
        if (names.Length == 0) return null;
        return load(names[rand.Next() % names.Length]);
    }

    /// <summary> An object that is generated simultaneously
    /// with a parent world_object. For example, an
    /// ore seam. </summary>
    public abstract class sub_generator : MonoBehaviour
    {
        public bool generated { get; private set; } = false;

        public void on_placement(biome.point point, 
            chunk chunk, int x_in_chunk, int z_in_chunk)
        {
            generate(point, chunk, x_in_chunk, z_in_chunk);
            generated = true;
        }

        protected abstract void generate(biome.point point,
            chunk chunk, int x_in_chunk, int z_in_chunk);
    }

#if UNITY_EDITOR
    [UnityEditor.CustomEditor(typeof(world_object), true)]
    class editor : UnityEditor.Editor
    {
        public override void OnInspectorGUI()
        {
            base.OnInspectorGUI();
            world_object wo = (world_object)target;
            UnityEditor.EditorGUILayout.TextField("Chunk coords: " + wo.x_in_chunk + ", " + wo.z_in_chunk);
        }
    }
#endif
}